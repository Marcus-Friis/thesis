<!DOCTYPE HTML>
<!-- NewPage -->
<html lang="en">
<head>
<!-- Generated by javadoc (11.0.13) on Sun Apr 17 12:06:48 CEST 2022 -->
<title>CanonicalForm</title>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<meta name="dc.created" content="2022-04-17">
<link rel="stylesheet" type="text/css" href="../stylesheet.css" title="Style">
<link rel="stylesheet" type="text/css" href="../jquery/jquery-ui.css" title="Style">
<script type="text/javascript" src="../script.js"></script>
<script type="text/javascript" src="../jquery/jszip/dist/jszip.min.js"></script>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils.min.js"></script>
<!--[if IE]>
<script type="text/javascript" src="../jquery/jszip-utils/dist/jszip-utils-ie.min.js"></script>
<![endif]-->
<script type="text/javascript" src="../jquery/jquery-3.5.1.js"></script>
<script type="text/javascript" src="../jquery/jquery-ui.js"></script>
</head>
<body>
<script type="text/javascript"><!--
    try {
        if (location.href.indexOf('is-external=true') == -1) {
            parent.document.title="CanonicalForm";
        }
    }
    catch(err) {
    }
//-->
var data = {"i0":6,"i1":10,"i2":6,"i3":10,"i4":6,"i5":6,"i6":10,"i7":10,"i8":9,"i9":10,"i10":6,"i11":10,"i12":6,"i13":10,"i14":10,"i15":10,"i16":10,"i17":6,"i18":10,"i19":6,"i20":10,"i21":10,"i22":10,"i23":6,"i24":10,"i25":10,"i26":10,"i27":10,"i28":10,"i29":6,"i30":10,"i31":10,"i32":10,"i33":10,"i34":10,"i35":9,"i36":10,"i37":10,"i38":10,"i39":10,"i40":10,"i41":10,"i42":10,"i43":6,"i44":6};
var tabs = {65535:["t0","All Methods"],1:["t1","Static Methods"],2:["t2","Instance Methods"],4:["t3","Abstract Methods"],8:["t4","Concrete Methods"]};
var altColor = "altColor";
var rowColor = "rowColor";
var tableTab = "tableTab";
var activeTableTab = "activeTableTab";
var pathtoroot = "../";
var useModuleDirectories = true;
loadScripts(document, 'script');</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
<header role="banner">
<nav role="navigation">
<div class="fixedNav">
<!-- ========= START OF TOP NAVBAR ======= -->
<div class="topNav"><a id="navbar.top">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.top" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.top.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_top">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<ul class="navListSearch">
<li><label for="search">SEARCH:</label>
<input type="text" id="search" value="search" disabled="disabled">
<input type="reset" id="reset" value="reset" disabled="disabled">
</li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_top");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.top">
<!--   -->
</a></div>
<!-- ========= END OF TOP NAVBAR ========= -->
</div>
<div class="navPadding">&nbsp;</div>
<script type="text/javascript"><!--
$('.navPadding').css('padding-top', $('.fixedNav').css("height"));
//-->
</script>
</nav>
</header>
<!-- ======== START OF CLASS DATA ======== -->
<main role="main">
<div class="header">
<div class="subTitle"><span class="packageLabelInType">Package</span>&nbsp;<a href="package-summary.html">moss</a></div>
<h2 title="Class CanonicalForm" class="title">Class CanonicalForm</h2>
</div>
<div class="contentContainer">
<ul class="inheritance">
<li>java.lang.Object</li>
<li>
<ul class="inheritance">
<li>moss.CanonicalForm</li>
</ul>
</li>
</ul>
<div class="description">
<ul class="blockList">
<li class="blockList">
<dl>
<dt>Direct Known Subclasses:</dt>
<dd><code><a href="CnFBreadth1.html" title="class in moss">CnFBreadth1</a></code>, <code><a href="CnFBreadth2.html" title="class in moss">CnFBreadth2</a></code>, <code><a href="CnFDepth.html" title="class in moss">CnFDepth</a></code></dd>
</dl>
<hr>
<pre>public abstract class <span class="typeNameLabel">CanonicalForm</span>
extends java.lang.Object</pre>
<div class="block">Class for canonical forms of graphs and their restricted extensions.
  <p>A canonical form object serves the purpose to define a canonical
  form of graphs and to create the corresponding restricted extensions
  of a fragment.</p>
  <p>The same extension object is reused to create extensions of
  several fragments instead of creating a new extension object for
  each fragment or even embedding. As a consequence the fragment and
  embedding to extend are not passed directly to a constructor, but
  to an initialization function. In addition, if embeddings are used,
  extended fragments are created in a delayed manner, recording only
  the extension edge at the beginning and turning it into a full
  fragment only on request (to avoid creating duplicates).</p>
  <p>The field <code>size</code>is used to indicate the type of the
  current extension. A negative size indicates a chain extension,
  with the absolute value of the size being the chain length.
  A zero size indicates a single edge extension (the standard case).
  Finally, a positive size indicates a ring extension, with the size
  being the number of nodes/edges in the ring.</p></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2002.03.11</dd>
</dl>
</li>
</ul>
</div>
<div class="summary">
<ul class="blockList">
<li class="blockList">
<!-- =========== FIELD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.summary">
<!--   -->
</a>
<h3>Field Summary</h3>
<table class="memberSummary">
<caption><span>Fields</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Field</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#all">all</a></span></code></th>
<td class="colLast">
<div class="block">all (remaining) ring flags of the current edge</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ALLEXTS">ALLEXTS</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: generate all extensions</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ALLORBS">ALLORBS</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: use node orbits for all extensions;
  not only those leading to a new node</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cedge">cedge</a></span></code></th>
<td class="colLast">
<div class="block">the edge type for chain extensions</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#CHAIN">CHAIN</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: variable length chain</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#chcnt">chcnt</a></span></code></th>
<td class="colLast">
<div class="block">the number of variable length chains</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#CLASSES">CLASSES</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: use node equivalence classes</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#cnode">cnode</a></span></code></th>
<td class="colLast">
<div class="block">the node type for chain extensions</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected long</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#curr">curr</a></span></code></th>
<td class="colLast">
<div class="block">the current ring flag</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dir">dir</a></span></code></th>
<td class="colLast">
<div class="block">whether the graphs are to be treated as directed</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#DIRECTED">DIRECTED</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: edges are to be treated as directed</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#dst">dst</a></span></code></th>
<td class="colLast">
<div class="block">the index of the current destination node</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#EDGE">EDGE</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: single edge</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#edgecnt">edgecnt</a></span></code></th>
<td class="colLast">
<div class="block">the number of new edges</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="Edge.html" title="class in moss">Edge</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#edges">edges</a></span></code></th>
<td class="colLast">
<div class="block">(relevant) edges of the extension</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#emap">emap</a></span></code></th>
<td class="colLast">
<div class="block">the edge map for making a graph canonic</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="Embedding.html" title="class in moss">Embedding</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#emb">emb</a></span></code></th>
<td class="colLast">
<div class="block">the embedding that is extended (may be <code>null</code>)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#EQVARS">EQVARS</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: equivalent ring variants</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#fixed">fixed</a></span></code></th>
<td class="colLast">
<div class="block">the number of fixed edges in a canonical form test</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#FIXED">FIXED</a></span></code></th>
<td class="colLast">
<div class="block">flag for a fixed edge in the ring order test</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="Fragment.html" title="class in moss">Fragment</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#frag">frag</a></span></code></th>
<td class="colLast">
<div class="block">the fragment  that is extended</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#idx">idx</a></span></code></th>
<td class="colLast">
<div class="block">the current edge index in the source node</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#max">max</a></span></code></th>
<td class="colLast">
<div class="block">the maximum fragment size (number of nodes)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#mode">mode</a></span></code></th>
<td class="colLast">
<div class="block">the extension mode (e.g.</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nmap">nmap</a></span></code></th>
<td class="colLast">
<div class="block">the node map for making a graph canonic</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nodecnt">nodecnt</a></span></code></th>
<td class="colLast">
<div class="block">the number of new nodes</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="Node.html" title="class in moss">Node</a>[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nodes">nodes</a></span></code></th>
<td class="colLast">
<div class="block">(relevant) nodes of the extension</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ORBITS">ORBITS</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: use node orbits to filter (if known)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pmax">pmax</a></span></code></th>
<td class="colLast">
<div class="block">the maximal position/position index of a ring edge</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pmin">pmin</a></span></code></th>
<td class="colLast">
<div class="block">the minimal position/current position index of a ring edge</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pos1">pos1</a></span></code></th>
<td class="colLast">
<div class="block">the current position 1 of equivalent edges for ring extensions</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#pos2">pos2</a></span></code></th>
<td class="colLast">
<div class="block">the current position 2 of equivalent edges for ring extensions</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rgmax">rgmax</a></span></code></th>
<td class="colLast">
<div class="block">the maximum ring size (number of nodes/edges)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#rgmin">rgmin</a></span></code></th>
<td class="colLast">
<div class="block">the minimum ring size (number of nodes/edges)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#RING">RING</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: ring (must be marked)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>static int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#SIMPLE">SIMPLE</a></span></code></th>
<td class="colLast">
<div class="block">extension mode flag: whether graphs/fragments are simple,
  that is, there is at most one edge between two nodes</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#size">size</a></span></code></th>
<td class="colLast">
<div class="block">the number of nodes in a ring (positive) or chain (negative)</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#src">src</a></span></code></th>
<td class="colLast">
<div class="block">the index of the current source node</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#sym">sym</a></span></code></th>
<td class="colLast">
<div class="block">whether the current ring is locally symmetric</div>
</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#type">type</a></span></code></th>
<td class="colLast">
<div class="block">the type of the extension edge (from <code>EDGE.type</code>)</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#verb">verb</a></span></code></th>
<td class="colLast">&nbsp;</td>
</tr>
<tr class="rowColor">
<td class="colFirst"><code>protected int[]</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#word">word</a></span></code></th>
<td class="colLast">
<div class="block">the code word for isCanonic/makeCanonic</div>
</td>
</tr>
<tr class="altColor">
<td class="colFirst"><code>protected <a href="ExtMgr.html" title="class in moss">ExtMgr</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#xemgr">xemgr</a></span></code></th>
<td class="colLast">
<div class="block">the extension edge manager (for extensions without embeddings)</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ======== CONSTRUCTOR SUMMARY ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.summary">
<!--   -->
</a>
<h3>Constructor Summary</h3>
<table class="memberSummary">
<caption><span>Constructors</span><span class="tabEnd">&nbsp;</span></caption>
<tr>
<th class="colFirst" scope="col">Constructor</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr class="altColor">
<th class="colConstructorName" scope="row"><code><span class="memberNameLink"><a href="#%3Cinit%3E()">CanonicalForm</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a canonical form object.</div>
</td>
</tr>
</table>
</li>
</ul>
</section>
<!-- ========== METHOD SUMMARY =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.summary">
<!--   -->
</a>
<h3>Method Summary</h3>
<table class="memberSummary">
<caption><span id="t0" class="activeTableTab"><span>All Methods</span><span class="tabEnd">&nbsp;</span></span><span id="t1" class="tableTab"><span><a href="javascript:show(1);">Static Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t2" class="tableTab"><span><a href="javascript:show(2);">Instance Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t3" class="tableTab"><span><a href="javascript:show(4);">Abstract Methods</a></span><span class="tabEnd">&nbsp;</span></span><span id="t4" class="tableTab"><span><a href="javascript:show(8);">Concrete Methods</a></span><span class="tabEnd">&nbsp;</span></span></caption>
<tr>
<th class="colFirst" scope="col">Modifier and Type</th>
<th class="colSecond" scope="col">Method</th>
<th class="colLast" scope="col">Description</th>
</tr>
<tr id="i0" class="altColor">
<td class="colFirst"><code>protected abstract int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#adaptRing(moss.Fragment,boolean)">adaptRing</a></span>&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag,
         boolean&nbsp;check)</code></th>
<td class="colLast">
<div class="block">Reorder the edges of a fragment with a ring extension.</div>
</td>
</tr>
<tr id="i1" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#chain()">chain</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a variable length chain extension.</div>
</td>
</tr>
<tr id="i2" class="altColor">
<td class="colFirst"><code>protected abstract int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareEdge(moss.Edge,moss.Edge,int)">compareEdge</a></span>&#8203;(<a href="Edge.html" title="class in moss">Edge</a>&nbsp;e1,
           <a href="Edge.html" title="class in moss">Edge</a>&nbsp;e2,
           int&nbsp;next)</code></th>
<td class="colLast">
<div class="block">Compare two edges with the precedence order of the canonical form.</div>
</td>
</tr>
<tr id="i3" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareRing(moss.Fragment)">compareRing</a></span>&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</code></th>
<td class="colLast">
<div class="block">Compare the current ring extension to a fragment.</div>
</td>
</tr>
<tr id="i4" class="altColor">
<td class="colFirst"><code>abstract int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareToFrag(moss.Fragment)">compareToFrag</a></span>&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</code></th>
<td class="colLast">
<div class="block">Compare the current extension to a given fragment.</div>
</td>
</tr>
<tr id="i5" class="rowColor">
<td class="colFirst"><code>protected abstract int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareWord(moss.Edge%5B%5D,int)">compareWord</a></span>&#8203;(<a href="Edge.html" title="class in moss">Edge</a>[]&nbsp;edges,
           int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Compare the current code word to the one of the given edge array.</div>
</td>
</tr>
<tr id="i6" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareWord(moss.Graph)">compareWord</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Compare the current code word to the one of the given graph.</div>
</td>
</tr>
<tr id="i7" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#compareWord(moss.Graph,int)">compareWord</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
           int&nbsp;edgecnt)</code></th>
<td class="colLast">
<div class="block">Compare the current code word to the one of the given graph.</div>
</td>
</tr>
<tr id="i8" class="altColor">
<td class="colFirst"><code>static <a href="CanonicalForm.html" title="class in moss">CanonicalForm</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#createCnF(java.lang.String)">createCnF</a></span>&#8203;(java.lang.String&nbsp;name)</code></th>
<td class="colLast">
<div class="block">Create an extension object corresponding to a given name.</div>
</td>
</tr>
<tr id="i9" class="rowColor">
<td class="colFirst"><code>protected java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#describe(moss.Graph)">describe</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Create the code word for a given graph as a string.</div>
</td>
</tr>
<tr id="i10" class="altColor">
<td class="colFirst"><code>protected abstract java.lang.String</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#describe(moss.Graph,boolean)">describe</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
        boolean&nbsp;create)</code></th>
<td class="colLast">
<div class="block">Create the code word for a given graph as a string.</div>
</td>
</tr>
<tr id="i11" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#equivClasses(moss.Graph)">equivClasses</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Find the node equivalence classes for a given graph.</div>
</td>
</tr>
<tr id="i12" class="altColor">
<td class="colFirst"><code>protected abstract boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#hasUnclosableRings(moss.Fragment)">hasUnclosableRings</a></span>&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</code></th>
<td class="colLast">
<div class="block">Check whether a fragment contains unclosable rings.</div>
</td>
</tr>
<tr id="i13" class="rowColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#init(moss.Fragment)">init</a></span>&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</code></th>
<td class="colLast">
<div class="block">Initialize the extension generation process.</div>
</td>
</tr>
<tr id="i14" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#init(moss.Fragment,moss.Embedding)">init</a></span>&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag,
    <a href="Embedding.html" title="class in moss">Embedding</a>&nbsp;emb)</code></th>
<td class="colLast">
<div class="block">Initialize the extension generation process.</div>
</td>
</tr>
<tr id="i15" class="rowColor">
<td class="colFirst"><code>protected void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initCanonic(moss.Graph,int)">initCanonic</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
           int&nbsp;fixed)</code></th>
<td class="colLast">
<div class="block">Initialize a canonical form test or generation.</div>
</td>
</tr>
<tr id="i16" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initFrag(moss.Fragment)">initFrag</a></span>&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</code></th>
<td class="colLast">
<div class="block">Initialize the extension generation process.</div>
</td>
</tr>
<tr id="i17" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#initVars()">initVars</a></span>()</code></th>
<td class="colLast">
<div class="block">Initialize the generation of equivalent ring extension variants.</div>
</td>
</tr>
<tr id="i18" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isCanExt(moss.Graph)">isCanExt</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Check whether a given graph is a canonic extension of its base.</div>
</td>
</tr>
<tr id="i19" class="rowColor">
<td class="colFirst"><code>protected abstract int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isCanonic(int,int,int)">isCanonic</a></span>&#8203;(int&nbsp;ei,
         int&nbsp;ni,
         int&nbsp;cnt)</code></th>
<td class="colLast">
<div class="block">Internal recursive function for the canonical form test.</div>
</td>
</tr>
<tr id="i20" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isCanonic(moss.Graph)">isCanonic</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Check whether a given graph is canonic.</div>
</td>
</tr>
<tr id="i21" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isCanonic(moss.Graph,int)">isCanonic</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
         int&nbsp;fixed)</code></th>
<td class="colLast">
<div class="block">Check whether a given graph is canonic.</div>
</td>
</tr>
<tr id="i22" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#isRingKey(moss.Graph,moss.Edge)">isRingKey</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
         <a href="Edge.html" title="class in moss">Edge</a>&nbsp;edge)</code></th>
<td class="colLast">
<div class="block">Check whether a prefix is a ring key.</div>
</td>
</tr>
<tr id="i23" class="rowColor">
<td class="colFirst"><code>protected abstract boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeCanonic(int,int,int)">makeCanonic</a></span>&#8203;(int&nbsp;ei,
           int&nbsp;ni,
           int&nbsp;cnt)</code></th>
<td class="colLast">
<div class="block">Internal recursive function for making a given graph canonic.</div>
</td>
</tr>
<tr id="i24" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeCanonic(moss.Graph)">makeCanonic</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Make a given graph canonic.</div>
</td>
</tr>
<tr id="i25" class="rowColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeCanonic(moss.Graph,int)">makeCanonic</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
           int&nbsp;keep)</code></th>
<td class="colLast">
<div class="block">Make a given graph canonic.</div>
</td>
</tr>
<tr id="i26" class="altColor">
<td class="colFirst"><code><a href="Embedding.html" title="class in moss">Embedding</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeEmbedding()">makeEmbedding</a></span>()</code></th>
<td class="colLast">
<div class="block">Create an embedding from the current extension.</div>
</td>
</tr>
<tr id="i27" class="rowColor">
<td class="colFirst"><code><a href="Fragment.html" title="class in moss">Fragment</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeFragment()">makeFragment</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a fragment from the current extension.</div>
</td>
</tr>
<tr id="i28" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeMap(moss.Graph,int)">makeMap</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
       int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Build a map for reordering the nodes and edges.</div>
</td>
</tr>
<tr id="i29" class="rowColor">
<td class="colFirst"><code>protected abstract void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeWord(moss.Edge%5B%5D,int)">makeWord</a></span>&#8203;(<a href="Edge.html" title="class in moss">Edge</a>[]&nbsp;edges,
        int&nbsp;n)</code></th>
<td class="colLast">
<div class="block">Create the (prefix of a) code word for a given edge array.</div>
</td>
</tr>
<tr id="i30" class="altColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeWord(moss.Graph)">makeWord</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</code></th>
<td class="colLast">
<div class="block">Create the code word for a given graph.</div>
</td>
</tr>
<tr id="i31" class="rowColor">
<td class="colFirst"><code>protected int</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#makeWord(moss.Graph,int)">makeWord</a></span>&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
        int&nbsp;edgecnt)</code></th>
<td class="colLast">
<div class="block">Create the code word for the first edges of a given graph.</div>
</td>
</tr>
<tr id="i32" class="altColor">
<td class="colFirst"><code>boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#next()">next</a></span>()</code></th>
<td class="colLast">
<div class="block">Create the next (restricted) extension of an embedding.</div>
</td>
</tr>
<tr id="i33" class="rowColor">
<td class="colFirst"><code><a href="Fragment.html" title="class in moss">Fragment</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#nextFrag()">nextFrag</a></span>()</code></th>
<td class="colLast">
<div class="block">Create the next (restricted) extension of a fragment.</div>
</td>
</tr>
<tr id="i34" class="altColor">
<td class="colFirst"><code>protected <a href="Graph.html" title="class in moss">Graph</a></code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#prepare(moss.Fragment)">prepare</a></span>&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</code></th>
<td class="colLast">
<div class="block">Prepare the rings of a fragment for adaptation and order test.</div>
</td>
</tr>
<tr id="i35" class="rowColor">
<td class="colFirst"><code>protected static void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#removeRings(moss.Edge)">removeRings</a></span>&#8203;(<a href="Edge.html" title="class in moss">Edge</a>&nbsp;edge)</code></th>
<td class="colLast">
<div class="block">Remove the flags of all rings an edge is contained in.</div>
</td>
</tr>
<tr id="i36" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#ring()">ring</a></span>()</code></th>
<td class="colLast">
<div class="block">Create a ring extension.</div>
</td>
</tr>
<tr id="i37" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setChainTypes(int,int)">setChainTypes</a></span>&#8203;(int&nbsp;node,
             int&nbsp;edge)</code></th>
<td class="colLast">
<div class="block">Set the node and edge type for chain extensions.</div>
</td>
</tr>
<tr id="i38" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setExtMgr(moss.ExtMgr)">setExtMgr</a></span>&#8203;(<a href="ExtMgr.html" title="class in moss">ExtMgr</a>&nbsp;xemgr)</code></th>
<td class="colLast">
<div class="block">Set the extension edge manager.</div>
</td>
</tr>
<tr id="i39" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setExtMode(int)">setExtMode</a></span>&#8203;(int&nbsp;mode)</code></th>
<td class="colLast">
<div class="block">Set the extension mode.</div>
</td>
</tr>
<tr id="i40" class="altColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setMaxSize(int)">setMaxSize</a></span>&#8203;(int&nbsp;max)</code></th>
<td class="colLast">
<div class="block">Set the maximum fragment size (to limit extensions).</div>
</td>
</tr>
<tr id="i41" class="rowColor">
<td class="colFirst"><code>void</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#setRingSizes(int,int)">setRingSizes</a></span>&#8203;(int&nbsp;rgmin,
            int&nbsp;rgmax)</code></th>
<td class="colLast">
<div class="block">Set the ring sizes for ring extensions.</div>
</td>
</tr>
<tr id="i42" class="altColor">
<td class="colFirst"><code>protected boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#useOrbits()">useOrbits</a></span>()</code></th>
<td class="colLast">
<div class="block">Whether node orbits are to be used to filter extensions.</div>
</td>
</tr>
<tr id="i43" class="rowColor">
<td class="colFirst"><code>protected abstract boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#validRing()">validRing</a></span>()</code></th>
<td class="colLast">
<div class="block">Check whether the current ring extension is valid.</div>
</td>
</tr>
<tr id="i44" class="altColor">
<td class="colFirst"><code>protected abstract boolean</code></td>
<th class="colSecond" scope="row"><code><span class="memberNameLink"><a href="#variant()">variant</a></span>()</code></th>
<td class="colLast">
<div class="block">Create the next ring extension variant.</div>
</td>
</tr>
</table>
<ul class="blockList">
<li class="blockList"><a id="methods.inherited.from.class.java.lang.Object">
<!--   -->
</a>
<h3>Methods inherited from class&nbsp;java.lang.Object</h3>
<code>clone, equals, finalize, getClass, hashCode, notify, notifyAll, toString, wait, wait, wait</code></li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
<div class="details">
<ul class="blockList">
<li class="blockList">
<!-- ============ FIELD DETAIL =========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="field.detail">
<!--   -->
</a>
<h3>Field Detail</h3>
<a id="SIMPLE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>SIMPLE</h4>
<pre>public static final&nbsp;int SIMPLE</pre>
<div class="block">extension mode flag: whether graphs/fragments are simple,
  that is, there is at most one edge between two nodes</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.SIMPLE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="DIRECTED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>DIRECTED</h4>
<pre>public static final&nbsp;int DIRECTED</pre>
<div class="block">extension mode flag: edges are to be treated as directed</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.DIRECTED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="EDGE">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EDGE</h4>
<pre>public static final&nbsp;int EDGE</pre>
<div class="block">extension mode flag: single edge</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.EDGE">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="RING">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>RING</h4>
<pre>public static final&nbsp;int RING</pre>
<div class="block">extension mode flag: ring (must be marked)</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.RING">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="CHAIN">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CHAIN</h4>
<pre>public static final&nbsp;int CHAIN</pre>
<div class="block">extension mode flag: variable length chain</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.CHAIN">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="EQVARS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>EQVARS</h4>
<pre>public static final&nbsp;int EQVARS</pre>
<div class="block">extension mode flag: equivalent ring variants</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.EQVARS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="ORBITS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ORBITS</h4>
<pre>public static final&nbsp;int ORBITS</pre>
<div class="block">extension mode flag: use node orbits to filter (if known)</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.ORBITS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="ALLEXTS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ALLEXTS</h4>
<pre>public static final&nbsp;int ALLEXTS</pre>
<div class="block">extension mode flag: generate all extensions</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.ALLEXTS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="CLASSES">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>CLASSES</h4>
<pre>public static final&nbsp;int CLASSES</pre>
<div class="block">extension mode flag: use node equivalence classes</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.CLASSES">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="ALLORBS">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ALLORBS</h4>
<pre>public static final&nbsp;int ALLORBS</pre>
<div class="block">extension mode flag: use node orbits for all extensions;
  not only those leading to a new node</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.ALLORBS">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="FIXED">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>FIXED</h4>
<pre>protected static final&nbsp;int FIXED</pre>
<div class="block">flag for a fixed edge in the ring order test</div>
<dl>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="../constant-values.html#moss.CanonicalForm.FIXED">Constant Field Values</a></dd>
</dl>
</li>
</ul>
<a id="mode">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>mode</h4>
<pre>protected&nbsp;int mode</pre>
<div class="block">the extension mode (e.g. <code>EDGE</code>, <code>RING</code>)</div>
</li>
</ul>
<a id="dir">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dir</h4>
<pre>protected&nbsp;boolean dir</pre>
<div class="block">whether the graphs are to be treated as directed</div>
</li>
</ul>
<a id="max">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>max</h4>
<pre>protected&nbsp;int max</pre>
<div class="block">the maximum fragment size (number of nodes)</div>
</li>
</ul>
<a id="rgmin">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rgmin</h4>
<pre>protected&nbsp;int rgmin</pre>
<div class="block">the minimum ring size (number of nodes/edges)</div>
</li>
</ul>
<a id="rgmax">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>rgmax</h4>
<pre>protected&nbsp;int rgmax</pre>
<div class="block">the maximum ring size (number of nodes/edges)</div>
</li>
</ul>
<a id="cnode">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cnode</h4>
<pre>protected&nbsp;int cnode</pre>
<div class="block">the node type for chain extensions</div>
</li>
</ul>
<a id="cedge">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>cedge</h4>
<pre>protected&nbsp;int cedge</pre>
<div class="block">the edge type for chain extensions</div>
</li>
</ul>
<a id="xemgr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>xemgr</h4>
<pre>protected&nbsp;<a href="ExtMgr.html" title="class in moss">ExtMgr</a> xemgr</pre>
<div class="block">the extension edge manager (for extensions without embeddings)</div>
</li>
</ul>
<a id="frag">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>frag</h4>
<pre>protected&nbsp;<a href="Fragment.html" title="class in moss">Fragment</a> frag</pre>
<div class="block">the fragment  that is extended</div>
</li>
</ul>
<a id="emb">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>emb</h4>
<pre>protected&nbsp;<a href="Embedding.html" title="class in moss">Embedding</a> emb</pre>
<div class="block">the embedding that is extended (may be <code>null</code>)</div>
</li>
</ul>
<a id="nodes">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodes</h4>
<pre>protected&nbsp;<a href="Node.html" title="class in moss">Node</a>[] nodes</pre>
<div class="block">(relevant) nodes of the extension</div>
</li>
</ul>
<a id="edges">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>edges</h4>
<pre>protected&nbsp;<a href="Edge.html" title="class in moss">Edge</a>[] edges</pre>
<div class="block">(relevant) edges of the extension</div>
</li>
</ul>
<a id="size">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>size</h4>
<pre>protected&nbsp;int size</pre>
<div class="block">the number of nodes in a ring (positive) or chain (negative)</div>
</li>
</ul>
<a id="nodecnt">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nodecnt</h4>
<pre>protected&nbsp;int nodecnt</pre>
<div class="block">the number of new nodes</div>
</li>
</ul>
<a id="edgecnt">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>edgecnt</h4>
<pre>protected&nbsp;int edgecnt</pre>
<div class="block">the number of new edges</div>
</li>
</ul>
<a id="chcnt">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>chcnt</h4>
<pre>protected&nbsp;int chcnt</pre>
<div class="block">the number of variable length chains</div>
</li>
</ul>
<a id="src">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>src</h4>
<pre>protected&nbsp;int src</pre>
<div class="block">the index of the current source node</div>
</li>
</ul>
<a id="idx">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>idx</h4>
<pre>protected&nbsp;int idx</pre>
<div class="block">the current edge index in the source node</div>
</li>
</ul>
<a id="dst">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>dst</h4>
<pre>protected&nbsp;int dst</pre>
<div class="block">the index of the current destination node</div>
</li>
</ul>
<a id="type">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>type</h4>
<pre>protected&nbsp;int type</pre>
<div class="block">the type of the extension edge (from <code>EDGE.type</code>)</div>
</li>
</ul>
<a id="all">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>all</h4>
<pre>protected&nbsp;long all</pre>
<div class="block">all (remaining) ring flags of the current edge</div>
</li>
</ul>
<a id="curr">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>curr</h4>
<pre>protected&nbsp;long curr</pre>
<div class="block">the current ring flag</div>
</li>
</ul>
<a id="sym">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>sym</h4>
<pre>protected&nbsp;boolean sym</pre>
<div class="block">whether the current ring is locally symmetric</div>
</li>
</ul>
<a id="pmin">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pmin</h4>
<pre>protected&nbsp;int pmin</pre>
<div class="block">the minimal position/current position index of a ring edge</div>
</li>
</ul>
<a id="pmax">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pmax</h4>
<pre>protected&nbsp;int pmax</pre>
<div class="block">the maximal position/position index of a ring edge</div>
</li>
</ul>
<a id="pos1">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pos1</h4>
<pre>protected&nbsp;int pos1</pre>
<div class="block">the current position 1 of equivalent edges for ring extensions</div>
</li>
</ul>
<a id="pos2">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>pos2</h4>
<pre>protected&nbsp;int pos2</pre>
<div class="block">the current position 2 of equivalent edges for ring extensions</div>
</li>
</ul>
<a id="fixed">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>fixed</h4>
<pre>protected&nbsp;int fixed</pre>
<div class="block">the number of fixed edges in a canonical form test</div>
</li>
</ul>
<a id="word">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>word</h4>
<pre>protected&nbsp;int[] word</pre>
<div class="block">the code word for isCanonic/makeCanonic</div>
</li>
</ul>
<a id="nmap">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nmap</h4>
<pre>protected&nbsp;int[] nmap</pre>
<div class="block">the node map for making a graph canonic</div>
</li>
</ul>
<a id="emap">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>emap</h4>
<pre>protected&nbsp;int[] emap</pre>
<div class="block">the edge map for making a graph canonic</div>
</li>
</ul>
<a id="verb">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>verb</h4>
<pre>protected&nbsp;boolean verb</pre>
</li>
</ul>
</li>
</ul>
</section>
<!-- ========= CONSTRUCTOR DETAIL ======== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="constructor.detail">
<!--   -->
</a>
<h3>Constructor Detail</h3>
<a id="&lt;init&gt;()">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>CanonicalForm</h4>
<pre>public&nbsp;CanonicalForm()</pre>
<div class="block">Create a canonical form object.
  <p>Since <code>CanonicalForm</code> is an abstract class, this
  constructor cannot be called directly to create an instance.
  Rather it is meant as a common initialization routine for
  subclasses of this class.</p></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2003.08.06 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
<!-- ============ METHOD DETAIL ========== -->
<section role="region">
<ul class="blockList">
<li class="blockList"><a id="method.detail">
<!--   -->
</a>
<h3>Method Detail</h3>
<a id="setExtMode(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setExtMode</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setExtMode&#8203;(int&nbsp;mode)</pre>
<div class="block">Set the extension mode.
  <p>The extension mode controls what extensions are created.
  By default only single edge extensions are created. Other modes
  include ring extensions and chain extensions.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>mode</code> - the extension mode
               (e.g. <code>EDGE</code> or <code>EDGE|RING</code>)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2009.04.29 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="setMaxSize(int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setMaxSize</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setMaxSize&#8203;(int&nbsp;max)</pre>
<div class="block">Set the maximum fragment size (to limit extensions).
  <p>The fragment size is the number of nodes of a fragment.
  The maximum fragment size is the maximum number of nodes a
  fragment may have. No extended fragments will be created that
  contain more than this number of nodes.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>max</code> - the maximum fragment size (number of nodes)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2009.04.29 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="setRingSizes(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setRingSizes</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setRingSizes&#8203;(int&nbsp;rgmin,
                         int&nbsp;rgmax)</pre>
<div class="block">Set the ring sizes for ring extensions.
  <p>These ring sizes are actually not needed for creating ring
  extensions, but only for adapting them, which is needed only
  if canonical form pruning is used.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>rgmin</code> - the minimal ring size (number of nodes/edges)</dd>
<dd><code>rgmax</code> - the maximal ring size (number of nodes/edges)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.07.01 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="setChainTypes(int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setChainTypes</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setChainTypes&#8203;(int&nbsp;node,
                          int&nbsp;edge)</pre>
<div class="block">Set the node and edge type for chain extensions.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>node</code> - the type of the chain nodes</dd>
<dd><code>edge</code> - the type of the chain edges</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.10.29 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="setExtMgr(moss.ExtMgr)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>setExtMgr</h4>
<pre class="methodSignature">public&nbsp;void&nbsp;setExtMgr&#8203;(<a href="ExtMgr.html" title="class in moss">ExtMgr</a>&nbsp;xemgr)</pre>
<div class="block">Set the extension edge manager.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>xemgr</code> - the extension edge manager</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2010.01.22 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="useOrbits()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>useOrbits</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;useOrbits()</pre>
<div class="block">Whether node orbits are to be used to filter extensions.
  <p>With the help of node orbits some equivalent siblings
  can be suppressed.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether node orbits are to be used</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2011.02.22 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="init(moss.Fragment,moss.Embedding)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>init</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;init&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag,
                    <a href="Embedding.html" title="class in moss">Embedding</a>&nbsp;emb)</pre>
<div class="block">Initialize the extension generation process.
  <p>Instead of creating a new extension object each time a fragment
  or an embedding has to be extended, the same extension object is
  reused, thus greatly reducing the overhead for memory allocation.
  As a consequence, the extension object has to be reinitialized
  for each fragment and each embedding that is to be extended.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frag</code> - the fragment  to extend</dd>
<dd><code>emb</code> - the embedding to extend
               (must be contained in the fragment or
               <code>null</code> for pure fragment extensions)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2003.08.06/2011.02.22 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="init(moss.Fragment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>init</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;init&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</pre>
<div class="block">Initialize the extension generation process.
  <p>This function initializes the extension process without
  embeddings, that is, based only on internally stored possible
  extension edges. This function is equivalent to
  <code>initFrag(Fragment)</code>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frag</code> - the fragment to extend</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2010.01.21 (Christian Borgelt)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#initFrag(moss.Fragment)"><code>initFrag(Fragment)</code></a></dd>
</dl>
</li>
</ul>
<a id="initFrag(moss.Fragment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initFrag</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;initFrag&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</pre>
<div class="block">Initialize the extension generation process.
  <p>This function initializes the extension process without
  embeddings, that is, based only on internally stored possible
  extension edges. This function is equivalent to
  <code>init(Fragment)</code>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frag</code> - the fragment to extend</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2011.02.18 (Christian Borgelt)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#init(moss.Fragment)"><code>init(Fragment)</code></a></dd>
</dl>
</li>
</ul>
<a id="next()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>next</h4>
<pre class="methodSignature">public&nbsp;boolean&nbsp;next()</pre>
<div class="block">Create the next (restricted) extension of an embedding.
  <p>Each time this function is called and returns
  <code>true</code>, a new (restricted) extension has been created.
  This extension may then be compared to already existing fragments
  (function <code>compareTo()</code>) or turned into a new fragment
  (function <code>makeFragment()</code>) or a new embedding
  (function <code>makeEmbedding()</code>).
  When all (restricted) extensions of the embedding passed to
  <code>init(Fragment,Embedding)</code> have been created,
  the function returns <code>false</code>.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether another extension was created</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2003.08.06/2011.02.22 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="nextFrag()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>nextFrag</h4>
<pre class="methodSignature">public&nbsp;<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;nextFrag()</pre>
<div class="block">Create the next (restricted) extension of a fragment.
  <p>Each call creates a new extended fragment or returns
  <code>null</code>. This function works without embeddings,
  (initialization: functions <code>init(Fragment)</code> or
  <code>initFrag(Fragment)</code>), but rather draws an a
  stored list of extension edges.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the next extended fragment or <code>null</code>.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2010.01.21/2011.02.22 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="ring()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>ring</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;ring()</pre>
<div class="block">Create a ring extension.
  <p>Follow a ring flag through the edges of the graph the
  embedding to extend refers to and collect the new edges for
  the extension. All created rings are checked with the function
  <code>validRing()</code>, restricting certain rings to a specific
  form (thus avoiding some unnecessary canonical form tests).
  If no (further) ring can be created, the function returns
  <code>false</code>, otherwise <code>true</code>.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether another ring extension was created</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2003.08.06 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="validRing()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>validRing</h4>
<pre class="methodSignature">protected abstract&nbsp;boolean&nbsp;validRing()</pre>
<div class="block">Check whether the current ring extension is valid.
  <p>In order to reduce the number of generated fragments, rings
  are usually generated in only one form. It is checked whether
  the source of the first new ring edge is minimal over all edges
  of the ring (so that a ring is always attached to the node with
  minimal index) and whether the first and last edges of the ring
  allow to fix an orientation of the ring, only one of which is
  considered valid. Invalid rings are discarded in the function
  <code>ring()</code> that creates ring extensions.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the ring is valid (has the correct form)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2005.08.11 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="initVars()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initVars</h4>
<pre class="methodSignature">protected abstract&nbsp;void&nbsp;initVars()</pre>
<div class="block">Initialize the generation of equivalent ring extension variants.
  <p>If a ring start (and possibly also ends) with an edge that is
  equivalent to one or more edges already in the fragment (that is,
  edges that start at the same node, have the same type, and lead
  to nodes of the same type), these edges must be spliced with the
  already existing equivalent edges in the fragment. All possible
  ways of splicing the equivalent edges have to be tried. This
  function initializes this variant generation.</p></div>
<dl>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.07.06 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="variant()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>variant</h4>
<pre class="methodSignature">protected abstract&nbsp;boolean&nbsp;variant()</pre>
<div class="block">Create the next ring extension variant.</div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether another ring variant was created</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.07.06 (Christian Borgelt)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#initVars()"><code>initVars()</code></a></dd>
</dl>
</li>
</ul>
<a id="adaptRing(moss.Fragment,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>adaptRing</h4>
<pre class="methodSignature">protected abstract&nbsp;int&nbsp;adaptRing&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag,
                                 boolean&nbsp;check)</pre>
<div class="block">Reorder the edges of a fragment with a ring extension.
  <p>After a ring extension it may be necessary to reorder the edges
  of the resulting fragment, so that the edges get into the proper
  order w.r.t. the canonical form. In addition, it must be checked
  whether rings were added in the right order (if several rings
  were added). If not, the ring extension cannot be adapted and
  thus the function returns -1.</p>
  <p>This function does not actually reorganize the fragment if the
  ring extension can be adapted, but only stores the edges and nodes
  in their new order in internal arrays. In addition, it creates a
  map for reorganizing the nodes and edges, also in an internal
  buffer. Either of these may later be used to actually reorganize
  the fragment (as a sub-graph) as well as the embeddings. Note
  that these arrays and maps are not filled/created if the fragment
  need not be changed in any way. In this case the function returns
  +1, otherwise the result is 0.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frag</code> - the fragment to adapt</dd>
<dd><code>check</code> - whether to check the ring order</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the ring adaptation succeeded, that is:
          <p><table cellpadding=0 cellspacing=0>
          <tr><td>-1,&nbsp;</td>
              <td>if the ring adaptation failed,</td></tr>
          <tr><td align="right">0,&nbsp;</td>
              <td>if the ring adaptation succeeded,
              but the fragment needs to be modified,</td></tr>
          <tr><td>+1,&nbsp;</td>
              <td>if the ring extension
                  need not be adapted.</td></tr>
          </table></p></dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.07.01 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="compareEdge(moss.Edge,moss.Edge,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareEdge</h4>
<pre class="methodSignature">protected abstract&nbsp;int&nbsp;compareEdge&#8203;(<a href="Edge.html" title="class in moss">Edge</a>&nbsp;e1,
                                   <a href="Edge.html" title="class in moss">Edge</a>&nbsp;e2,
                                   int&nbsp;next)</pre>
<div class="block">Compare two edges with the precedence order of the canonical form.
  <p>A canonical form usually allows to compare two edges in the
  necessary way by fixing a specific precedence order of the
  defining properties of the edges.</p>
  <p>This function is meant to compare edges from the same graph
  at each point where the next edge needs to be selected, when the
  graph (or rather its edge array) is rebuilt. At such a point
  all nodes incident to already processed edges are numbered.
  However, one of the nodes incident to the compared edges may
  not have been numbered yet. As this would make it impossible to
  compare the edges, the next number to be given to a node is
  also passed to the function.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>e1</code> - the first  edge to compare</dd>
<dd><code>e2</code> - the second edge to compare</dd>
<dd><code>next</code> - the index with which to number the next node</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the first edge is smaller (-1) or greater than
          (+1) or equal to (0) the second edge</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.04.11 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="removeRings(moss.Edge)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>removeRings</h4>
<pre class="methodSignature">protected static&nbsp;void&nbsp;removeRings&#8203;(<a href="Edge.html" title="class in moss">Edge</a>&nbsp;edge)</pre>
<div class="block">Remove the flags of all rings an edge is contained in.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>edge</code> - the edge to process</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2007.03.24 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="prepare(moss.Fragment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>prepare</h4>
<pre class="methodSignature">protected&nbsp;<a href="Graph.html" title="class in moss">Graph</a>&nbsp;prepare&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</pre>
<div class="block">Prepare the rings of a fragment for adaptation and order test.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frag</code> - the fragment to prepare</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the fragment as a graph</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2007.03.24 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="isRingKey(moss.Graph,moss.Edge)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isRingKey</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;isRingKey&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
                            <a href="Edge.html" title="class in moss">Edge</a>&nbsp;edge)</pre>
<div class="block">Check whether a prefix is a ring key.
  <p>This function presupposes that the internal edge buffer
  contains the graph's edges in adapted order.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to check</dd>
<dd><code>edge</code> - the edge at the end of the prefix to check</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2007.03.23 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="chain()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>chain</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;chain()</pre>
<div class="block">Create a variable length chain extension.
  <p>A variable length chain consists of nodes of the same type
  that are connected by edges of the same type. There must not
  be any branches. This function is called when the function
  <code>next()</code> detects a possible start of a chain.
  However, the check in <code>next()</code> is limited and thus
  it may be that no variable length chain can be created. In this
  case this function returns <code>false</code>.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether a chain extension was created</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2003.02.19 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="compareToFrag(moss.Fragment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareToFrag</h4>
<pre class="methodSignature">public abstract&nbsp;int&nbsp;compareToFrag&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</pre>
<div class="block">Compare the current extension to a given fragment.
  <p>This function is used to determine whether the current
  extension is equivalent to a previously created one (and thus
  only an embedding has to be created from it, which is then added
  to the corresponding fragment) or not (and thus a new fragment
  has to be created). It is designed as a comparison function,
  because the created fragments are kept as an ordered array,
  so that a binary search becomes possible.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frag</code> - the fragment to compare to</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd><code>-1</code>, <code>0</code>, or <code>+1</code>
          as the fragment described by this extension is less
          than, equal to, or greater than the fragment given
          as an argument</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2002.04.02 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="compareRing(moss.Fragment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareRing</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;compareRing&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</pre>
<div class="block">Compare the current ring extension to a fragment.
  <p>This is a sub-function of the function <code>compareTo</code>,
  which compares the current extension to a given fragment whatever
  the type of the extension may be. If both the current extension
  and the given fragment describe a ring extension, this function
  is called to compare them.</p>
  <p>This function assumes that the first edge of the ring together
  with its destination node have already been compared (namely in
  the function <code>compareTo</code>) and thus only compares the
  rest of the new ring edges.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frag</code> - the fragment to compare to</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the current extension is smaller (-1) or greater
          than (+1) or equal to (0) the given fragment</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.12 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="hasUnclosableRings(moss.Fragment)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>hasUnclosableRings</h4>
<pre class="methodSignature">protected abstract&nbsp;boolean&nbsp;hasUnclosableRings&#8203;(<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;frag)</pre>
<div class="block">Check whether a fragment contains unclosable rings.
  <p>If the output is restricted to fragments containing only closed
  rings, the restricted extensions (as they can be derived from a
  canonical form) render certain nodes unextendable. If such a node
  has only one incident ring edge, the ring of which this edge is
  part cannot be closed by future extensions. Hence neither this
  fragment nor any of its extensions can produce output and thus
  it can be pruned.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>frag</code> - the fragment to check for unclosable rings</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the given fragment contains unclosable rings</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.17 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeFragment()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeFragment</h4>
<pre class="methodSignature">public&nbsp;<a href="Fragment.html" title="class in moss">Fragment</a>&nbsp;makeFragment()</pre>
<div class="block">Create a fragment from the current extension.
  <p>This function is called when the current extension is not
  equal to an already existing fragment and thus a new fragment
  has to be created.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current extension as a fragment</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2005.08.10 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeEmbedding()">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeEmbedding</h4>
<pre class="methodSignature">public&nbsp;<a href="Embedding.html" title="class in moss">Embedding</a>&nbsp;makeEmbedding()</pre>
<div class="block">Create an embedding from the current extension.
  <p>This function is called when the current extension is equal
  to an already existing fragment and thus only a new embedding
  has to be added to that fragment.</p></div>
<dl>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the current extension as an embedding</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.10.24 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="initCanonic(moss.Graph,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>initCanonic</h4>
<pre class="methodSignature">protected&nbsp;void&nbsp;initCanonic&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
                           int&nbsp;fixed)</pre>
<div class="block">Initialize a canonical form test or generation.
  <p>For a canonical form test or for the procedure that makes a
  graph canonical, the internal arrays have to have a certain
  size (depending on the size of the graph, that is, the number
  of its nodes and edges), so that they can hold the necessary data.
  This function ensures proper array sizes and also initializes some
  variables.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to make canonic or to check</dd>
<dd><code>fixed</code> - the number of fixed (immovable) edges</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2003.08.06 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeWord(moss.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeWord</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;makeWord&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</pre>
<div class="block">Create the code word for a given graph.
  <p>The code word is created for the current order of the edges
  as it is found in the graph. As a consequence the resulting
  code word may or may not be the canonical code word. If the
  canonical code word is desired, the graph has to be made
  canonic by calling the function <code>makeCanonic()</code>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph for which to create the code word</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of generated "characters" (array entries)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.03 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeWord(moss.Graph,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeWord</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;makeWord&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
                       int&nbsp;edgecnt)</pre>
<div class="block">Create the code word for the first edges of a given graph.
  <p>In other words, this function creates the prefix of the
  code word for the given graph, using only the first edges.
  If, however, <code>edgecnt == graph.edgecnt</code>, all edges
  are used and thus a full code word is created.</p>
  <p>The code word is created for the current order of the edges
  as it is found in the graph. As a consequence the resulting
  code word may or may not be the canonical code word. If the
  canonical code word is desired, the graph has to be made
  canonic by calling the function <code>makeCanonic()</code>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph for which to create the code word</dd>
<dd><code>edgecnt</code> - the number of edges to consider</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the number of generated "characters" (array entries)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.03 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeWord(moss.Edge[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeWord</h4>
<pre class="methodSignature">protected abstract&nbsp;void&nbsp;makeWord&#8203;(<a href="Edge.html" title="class in moss">Edge</a>[]&nbsp;edges,
                                 int&nbsp;n)</pre>
<div class="block">Create the (prefix of a) code word for a given edge array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>edges</code> - the array of edges for which to create the code word</dd>
<dd><code>n</code> - the number of edges to consider</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.03 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="compareWord(moss.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareWord</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;compareWord&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</pre>
<div class="block">Compare the current code word to the one of the given graph.
  <p>This function assumes that <code>makeWord()</code> has been
  called before (for some other graph or a different form of the
  same graph) and has placed a code word into the internal code
  word buffer. This code word is then compared to the code word
  that would be created for the given graph (without explicitely
  generating the code word for the graph).</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to compare to</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the internal code word is smaller (-1) or greater
          than (+1) or equal to (0) the code word of the graph</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.06.07 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="compareWord(moss.Graph,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareWord</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;compareWord&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
                          int&nbsp;edgecnt)</pre>
<div class="block">Compare the current code word to the one of the given graph.
  <p>The comparison takes only the first <code>edgecnt</code>
  edges into account. Any remaining edges are not compared.
  If, however, <code>edgecnt == graph.edgecnt</code>, the full
  code words are compared.</p>
  <p>This function assumes that <code>makeWord()</code> has been
  called before and has placed a code word into the internal code
  word buffer. This code word is then compared to the code word
  that would be created for the given graph (without explicitely
  generating the code word for the graph).</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to compare to</dd>
<dd><code>edgecnt</code> - the number of edges to consider</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the internal code word is smaller (-1) or greater
          than (+1) or equal to (0) the code word of the graph</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.06.07 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="compareWord(moss.Edge[],int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>compareWord</h4>
<pre class="methodSignature">protected abstract&nbsp;int&nbsp;compareWord&#8203;(<a href="Edge.html" title="class in moss">Edge</a>[]&nbsp;edges,
                                   int&nbsp;n)</pre>
<div class="block">Compare the current code word to the one of the given edge array.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>edges</code> - the array of edges to compare to</dd>
<dd><code>n</code> - the number of edges to consider</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the internal code word is smaller (-1) or greater
          than (+1) or equal to (0) the code word of the edges array</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.06.07 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="isCanonic(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCanonic</h4>
<pre class="methodSignature">protected abstract&nbsp;int&nbsp;isCanonic&#8203;(int&nbsp;ei,
                                 int&nbsp;ni,
                                 int&nbsp;cnt)</pre>
<div class="block">Internal recursive function for the canonical form test.
  <p>In each recursive call to this function one edge is checked.
  If a possibility to construct a lexicographically smaller (prefix
  of a) code word is found or if all (prefixes of) code words that
  could be constructed are lexicographically greater, the function
  returns directly. Only if there is a possibility to construct an
  equal prefix, the function calls itself recursively.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ei</code> - the current edge index</dd>
<dd><code>ni</code> - the current node index</dd>
<dd><code>cnt</code> - the number of already numbered nodes</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the lowest edge index at which the considered graph
          differs from the canonical form (in this recursion)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2005.08.11 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="isCanonic(moss.Graph,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCanonic</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;isCanonic&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
                        int&nbsp;fixed)</pre>
<div class="block">Check whether a given graph is canonic.
  <p>In addition, if the graph is not canonic, it is determined
  whether the canonical form differs from the form of the graph
  within the first <code>fixed</code> edges. Hence there are three
  possible outcomes: (1) the graph is in canonical form (return
  value 1), (2) the graph differs from the canonical form in the
  first <code>fixed</code> edges (return value -1), (3) the graph
  is not in canonical form, but does not differ in the first
  <code>fixed</code> edges (return value 0).</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to check for canonical form</dd>
<dd><code>fixed</code> - the number of fixed edges</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>-1, if the graph differs from the canonical form
              in the first <code>fixed</code> edges,<br>
           0, if the graph is not canonical, but does not
              differ from the canonical form in the first
              <code>fixed</code> edges (but only in some
              later edge description),<br>
           1, if the graph is canonical.</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2005.08.11 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="isCanonic(moss.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCanonic</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;isCanonic&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</pre>
<div class="block">Check whether a given graph is canonic.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to check for canonical form</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the given graph is canonic</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2009.05.07 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeCanonic(int,int,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeCanonic</h4>
<pre class="methodSignature">protected abstract&nbsp;boolean&nbsp;makeCanonic&#8203;(int&nbsp;ei,
                                       int&nbsp;ni,
                                       int&nbsp;cnt)</pre>
<div class="block">Internal recursive function for making a given graph canonic.
  <p>This function works in basically the same way as the analogous
  function <code>isCanonic()</code>, with the only difference that
  whenever a smaller (prefix of a) code word is found, the function
  is not terminated, but continues with the new (prefix of a) code
  word, thus constructing the lexicographically smallest code word.
  </p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>ei</code> - the current edge index</dd>
<dd><code>ni</code> - the current node index</dd>
<dd><code>cnt</code> - the number of already numbered nodes</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the considered graphs needs to be changed</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.03 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeCanonic(moss.Graph,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeCanonic</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;makeCanonic&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
                              int&nbsp;keep)</pre>
<div class="block">Make a given graph canonic.
  <p>The form of the graph (that is, the order of its nodes
  and edges) is changed in such a way that it produces the
  lexicographically smallest code word. The first <code>keep</code>
  edges are left unchanged. If <code>keep = 0</code>, then all
  edges may change their positions, but the first node is kept.
  Only if <code>keep = -1</code> the graph may be completely
  reorganized.</p>
  <p>This function does not actually reorganize the graph, but
  only stores the found canonical order of the edges and nodes in
  internal arrays. In addition, it creates maps for reorganizing
  the nodes and edges, also in internal buffers. Either of these
  may later be used to actually reorganize the graph as well
  as any embeddings (if the graph represents a fragment). Note
  that these arrays and maps are not filled/created if the graph
  is already in canonical form. In this case the function returns
  <code>false</code>, thus indicating that no reorganization is
  necessary.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to make canonic</dd>
<dd><code>keep</code> - the number of edges to keep</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the graphs needs to be changed</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.03 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeCanonic(moss.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeCanonic</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;makeCanonic&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</pre>
<div class="block">Make a given graph canonic.
  <p>The form of the graph (that is, the order of its nodes
  and edges) is changed in such a way that it produces the
  lexicographically smallest code word.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to make canonic</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the graphs needs to be changed</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2009.05.07 (Christian Borgelt)</dd>
<dt><span class="seeLabel">See Also:</span></dt>
<dd><a href="#makeCanonic(moss.Graph,int)"><code>makeCanonic(Graph,int)</code></a></dd>
</dl>
</li>
</ul>
<a id="equivClasses(moss.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>equivClasses</h4>
<pre class="methodSignature">protected&nbsp;int&nbsp;equivClasses&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</pre>
<div class="block">Find the node equivalence classes for a given graph.
  <p>This function modifies the types of the nodes of the graph.
  Since the original types may be needed again later, they have
  to be saved, and restored when the equivalence classes are not
  needed anymore. It also destroys the node markers and sets them
  all to <code>-1</code>.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph for which to find node equivalence classes</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2011.03.01 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="isCanExt(moss.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>isCanExt</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;isCanExt&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</pre>
<div class="block">Check whether a given graph is a canonic extension of its base.
  <p>The base of the graph is the graph without the last edge in
  in its edge array (and without the last node if this node is
  incident to no other edge). The difference to the function
  <code>isCanonic()</code> is that this function computes node
  equivalence classes to simplify the construction of the canonical
  code word.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph to check</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the given graph is a canonic extension</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2011.03.01 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="makeMap(moss.Graph,int)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>makeMap</h4>
<pre class="methodSignature">protected&nbsp;boolean&nbsp;makeMap&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
                          int&nbsp;n)</pre>
<div class="block">Build a map for reordering the nodes and edges.
  <p>This map describes the transition from the original form to
  the canonical form and is built in the <code>word</code> array
  of this extension structure. The first <code>graph.edgecnt</code>
  elements of this array contain the new indices of the edges, the
  next <code>graph.nodecnt</code> elements contain the new indices
  of the nodes. The map is used to reorganize the embeddings of a
  fragment.</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph for which to build the map</dd>
<dd><code>n</code> - the highest already fixed node index</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>whether the map is the identity (no change needed)</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.08 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="describe(moss.Graph)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>describe</h4>
<pre class="methodSignature">protected&nbsp;java.lang.String&nbsp;describe&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph)</pre>
<div class="block">Create the code word for a given graph as a string.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph for which to create a code word</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a code word (as a string) for the given graph</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.10 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="describe(moss.Graph,boolean)">
<!--   -->
</a>
<ul class="blockList">
<li class="blockList">
<h4>describe</h4>
<pre class="methodSignature">protected abstract&nbsp;java.lang.String&nbsp;describe&#8203;(<a href="Graph.html" title="class in moss">Graph</a>&nbsp;graph,
                                             boolean&nbsp;create)</pre>
<div class="block">Create the code word for a given graph as a string.
  <p>This function allows for the code word of the graph already
  being available in the internal code word buffer. In this case
  the function should be called with <code>create == false</code>
  (the graph is only used to retrieve the number of edges).</p></div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>graph</code> - the graph for which to create a code word string</dd>
<dd><code>create</code> - whether the code word needs to be created</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>a code word (as a string) for the given graph</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2006.05.10 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
<a id="createCnF(java.lang.String)">
<!--   -->
</a>
<ul class="blockListLast">
<li class="blockList">
<h4>createCnF</h4>
<pre class="methodSignature">public static&nbsp;<a href="CanonicalForm.html" title="class in moss">CanonicalForm</a>&nbsp;createCnF&#8203;(java.lang.String&nbsp;name)</pre>
<div class="block">Create an extension object corresponding to a given name.</div>
<dl>
<dt><span class="paramLabel">Parameters:</span></dt>
<dd><code>name</code> - the name of the extension type</dd>
<dt><span class="returnLabel">Returns:</span></dt>
<dd>the created extension</dd>
<dt><span class="simpleTagLabel">Since:</span></dt>
<dd>2009.08.04 (Christian Borgelt)</dd>
</dl>
</li>
</ul>
</li>
</ul>
</section>
</li>
</ul>
</div>
</div>
</main>
<!-- ========= END OF CLASS DATA ========= -->
<footer role="contentinfo">
<nav role="navigation">
<!-- ======= START OF BOTTOM NAVBAR ====== -->
<div class="bottomNav"><a id="navbar.bottom">
<!--   -->
</a>
<div class="skipNav"><a href="#skip.navbar.bottom" title="Skip navigation links">Skip navigation links</a></div>
<a id="navbar.bottom.firstrow">
<!--   -->
</a>
<ul class="navList" title="Navigation">
<li><a href="package-summary.html">Package</a></li>
<li class="navBarCell1Rev">Class</li>
<li><a href="package-tree.html">Tree</a></li>
<li><a href="../deprecated-list.html">Deprecated</a></li>
<li><a href="../index-all.html">Index</a></li>
<li><a href="../help-doc.html">Help</a></li>
</ul>
</div>
<div class="subNav">
<ul class="navList" id="allclasses_navbar_bottom">
<li><a href="../allclasses.html">All&nbsp;Classes</a></li>
</ul>
<div>
<script type="text/javascript"><!--
  allClassesLink = document.getElementById("allclasses_navbar_bottom");
  if(window==top) {
    allClassesLink.style.display = "block";
  }
  else {
    allClassesLink.style.display = "none";
  }
  //-->
</script>
<noscript>
<div>JavaScript is disabled on your browser.</div>
</noscript>
</div>
<div>
<ul class="subNavList">
<li>Summary:&nbsp;</li>
<li>Nested&nbsp;|&nbsp;</li>
<li><a href="#field.summary">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.summary">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.summary">Method</a></li>
</ul>
<ul class="subNavList">
<li>Detail:&nbsp;</li>
<li><a href="#field.detail">Field</a>&nbsp;|&nbsp;</li>
<li><a href="#constructor.detail">Constr</a>&nbsp;|&nbsp;</li>
<li><a href="#method.detail">Method</a></li>
</ul>
</div>
<a id="skip.navbar.bottom">
<!--   -->
</a></div>
<!-- ======== END OF BOTTOM NAVBAR ======= -->
</nav>
</footer>
</body>
</html>
